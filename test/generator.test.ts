import { generateRestAdapter } from "../src/generator";
import type { ParsedService } from "../src/types";

describe("Code Generator", () => {
  const mockServices: ParsedService[] = [
    {
      packageName: "users.v1",
      serviceName: "UserService",
      fullName: "users.v1.UserService",
      methods: [
        {
          name: "GetUser",
          inputType: "GetUserRequest",
          outputType: "GetUserResponse",
          httpMethod: "GET",
          httpPath: "/v1/users/{user_id}",
        },
        {
          name: "CreateUser",
          inputType: "CreateUserRequest",
          outputType: "CreateUserResponse",
          httpMethod: "POST",
          httpPath: "/v1/users",
          body: "*",
        },
      ],
    },
  ];

  describe("multiple services", () => {
    const multipleServices: ParsedService[] = [
      {
        packageName: "users.v1",
        serviceName: "UserService",
        fullName: "users.v1.UserService",
        methods: [
          {
            name: "GetUser",
            inputType: "GetUserRequest",
            outputType: "GetUserResponse",
            httpMethod: "GET",
            httpPath: "/v1/users/{id}",
          },
        ],
      },
      {
        packageName: "orders.v1",
        serviceName: "OrderService",
        fullName: "orders.v1.OrderService",
        methods: [
          {
            name: "GetOrder",
            inputType: "GetOrderRequest",
            outputType: "GetOrderResponse",
            httpMethod: "GET",
            httpPath: "/v1/orders/{id}",
          },
        ],
      },
    ];

    it("should include all services in path mappings", () => {
      const result = generateRestAdapter(multipleServices);

      expect(result).toContain("/users.v1.UserService/GetUser");
      expect(result).toContain("/orders.v1.OrderService/GetOrder");
    });
  });

  describe("generateRestAdapter", () => {
    it("should generate valid TypeScript code", () => {
      const result = generateRestAdapter(mockServices);

      expect(result).toContain("AUTO-GENERATED by connect-rest-adapter");
      expect(result).toContain("export function restAdapter");
      expect(result).toContain("pathMappings");
    });

    it("should include correct path mappings", () => {
      const result = generateRestAdapter(mockServices);

      expect(result).toContain("/users.v1.UserService/GetUser");
      expect(result).toContain("/v1/users/{user_id}");
    });

    it("should include snakeToCamel helper", () => {
      const result = generateRestAdapter(mockServices);
      expect(result).toContain("function snakeToCamel");
    });

    it("should include camelToSnake helper", () => {
      const result = generateRestAdapter(mockServices);
      expect(result).toContain("function camelToSnake");
    });

    it("should include flattenToParams helper", () => {
      const result = generateRestAdapter(mockServices);
      expect(result).toContain("function flattenToParams");
    });

    it("should include RestAdapterOptions interface", () => {
      const result = generateRestAdapter(mockServices);
      expect(result).toContain("export interface RestAdapterOptions");
      expect(result).toContain("queryParamFormat");
    });

    it("should accept options parameter", () => {
      const result = generateRestAdapter(mockServices);
      expect(result).toContain("restAdapter(options?: RestAdapterOptions)");
    });

    it("should remove Connect-Protocol-Version header", () => {
      const result = generateRestAdapter(mockServices);
      expect(result).toContain('headers.delete("Connect-Protocol-Version")');
    });

    it("should default queryParamFormat to camelCase", () => {
      const result = generateRestAdapter(mockServices);
      expect(result).toContain('options?.queryParamFormat ?? "camelCase"');
    });
  });

  describe("body annotation handling", () => {
    it("should include body field in path mappings when specified", () => {
      const services: ParsedService[] = [
        {
          packageName: "users.v1",
          serviceName: "UserService",
          fullName: "users.v1.UserService",
          methods: [
            {
              name: "UpdateUser",
              inputType: "UpdateUserRequest",
              outputType: "UpdateUserResponse",
              httpMethod: "PATCH",
              httpPath: "/v1/users/{user_id}",
              body: "user",
            },
          ],
        },
      ];

      const result = generateRestAdapter(services);
      expect(result).toContain('"body": "user"');
    });

    it("should include body: * in path mappings", () => {
      const result = generateRestAdapter(mockServices);
      expect(result).toContain('"body": "*"');
    });

    it("should not include body field when not specified", () => {
      const services: ParsedService[] = [
        {
          packageName: "users.v1",
          serviceName: "UserService",
          fullName: "users.v1.UserService",
          methods: [
            {
              name: "GetUser",
              inputType: "GetUserRequest",
              outputType: "GetUserResponse",
              httpMethod: "GET",
              httpPath: "/v1/users/{user_id}",
            },
          ],
        },
      ];

      const result = generateRestAdapter(services);
      // The GET mapping should not have a body field
      expect(result).not.toMatch(
        /"\/users\.v1\.UserService\/GetUser"[\s\S]*?"body"/,
      );
    });

    it("should handle body: specificField differently from body: *", () => {
      const result = generateRestAdapter(mockServices);
      // The generated code should have logic for specific body fields
      expect(result).toContain('mapping.body && mapping.body !== "*"');
      expect(result).toContain("remaining[mapping.body]");
    });
  });
});
