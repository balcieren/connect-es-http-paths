/**
 * Code generator for REST adapter
 * @module generator
 */

import { getConnectPath } from "./parser";
import type { ParsedService, PathMapping } from "./types";

/**
 * Generate path mappings from parsed services
 */
function generatePathMappings(
  services: ParsedService[],
): Record<string, PathMapping> {
  const mappings: Record<string, PathMapping> = {};

  for (const service of services) {
    for (const method of service.methods) {
      const connectPath = getConnectPath(service, method);
      mappings[connectPath] = {
        path: method.httpPath,
        method: method.httpMethod,
      };
    }
  }

  return mappings;
}

/**
 * Generate the rest-adapter.ts content
 * Creates a custom fetch adapter that rewrites Connect URLs to REST paths
 */
export function generateRestAdapter(services: ParsedService[]): string {
  const pathMappings = generatePathMappings(services);

  return `/**
 * AUTO-GENERATED by connect-rest-adapter
 * DO NOT EDIT MANUALLY
 *
 * Custom fetch adapter that rewrites Connect-RPC URLs to REST paths
 * defined in google.api.http annotations.
 *
 * Usage:
 *   import { createConnectTransport } from "@connectrpc/connect-web";
 *   import { restAdapter } from "./rest-adapter";
 *
 *   const transport = createConnectTransport({
 *     baseUrl: "http://localhost:3000",
 *     fetch: restAdapter(),
 *   });
 */

export interface RestAdapterOptions {
  /**
   * Format for query parameter keys.
   * - "camelCase": pageSize → pageSize (protobuf JSON format, default)
   * - "snake_case": pageSize → page_size (proto field names)
   *
   * @default "camelCase"
   */
  queryParamFormat?: "camelCase" | "snake_case";
}

const pathMappings: Record<string, { path: string; method: string }> = ${JSON.stringify(
    pathMappings,
    null,
    2,
  )
    .replace(/"/g, '"')
    .split("\n")
    .map((line, i) => (i === 0 ? line : "  " + line))
    .join("\n")};

function snakeToCamel(s: string): string {
  return s.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
}

function camelToSnake(s: string): string {
  return s.replace(/[A-Z]/g, (c) => \`_\${c.toLowerCase()}\`);
}

function flattenToParams(
  obj: Record<string, unknown>,
  prefix = "",
  format: "snake_case" | "camelCase" = "snake_case",
): [string, string][] {
  const result: [string, string][] = [];
  for (const [key, val] of Object.entries(obj)) {
    if (val == null) continue;
    const formattedKey = format === "snake_case" ? camelToSnake(key) : key;
    const fullKey = prefix ? \`\${prefix}.\${formattedKey}\` : formattedKey;
    if (typeof val === "object" && !Array.isArray(val)) {
      result.push(
        ...flattenToParams(val as Record<string, unknown>, fullKey, format),
      );
    } else if (Array.isArray(val)) {
      for (const item of val) result.push([fullKey, String(item)]);
    } else {
      result.push([fullKey, String(val)]);
    }
  }
  return result;
}

/**
 * Creates a custom fetch function that rewrites Connect-RPC URLs to REST paths.
 *
 * Pass this to \`createConnectTransport({ fetch: restAdapter() })\`
 * to have requests automatically use REST paths defined in google.api.http annotations.
 *
 * @param options - Configuration options
 * @returns A fetch-compatible function
 */
export function restAdapter(options?: RestAdapterOptions): typeof globalThis.fetch {
  const queryParamFormat = options?.queryParamFormat ?? "camelCase";

  return async (input, init) => {
    const url =
      typeof input === "string"
        ? new URL(input)
        : input instanceof URL
          ? new URL(input.href)
          : new URL((input as Request).url);

    const mapping = pathMappings[url.pathname];
    if (!mapping) return globalThis.fetch(input, init);

    let bodyObj: Record<string, unknown> = {};
    if (init?.body) {
      try {
        const raw =
          init.body instanceof Uint8Array || init.body instanceof ArrayBuffer
            ? new TextDecoder().decode(init.body)
            : String(init.body);
        bodyObj = JSON.parse(raw);
      } catch {
        return globalThis.fetch(input, init);
      }
    }

    const usedKeys = new Set<string>();
    const restPath = mapping.path.replace(/\\{(\\w+)\\}/g, (_, snake) => {
      const camel = snakeToCamel(snake);
      usedKeys.add(camel);
      return encodeURIComponent(String(bodyObj[camel] ?? ""));
    });

    const remaining: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(bodyObj)) {
      if (!usedKeys.has(k)) remaining[k] = v;
    }

    const method = mapping.method;
    const newUrl = new URL(restPath, url.origin);
    const headers = new Headers(init?.headers);
    headers.delete("Connect-Protocol-Version");
    headers.set("Content-Type", "application/json");
    const newInit: RequestInit = { ...init, method, headers };

    if (method === "GET" || method === "DELETE") {
      for (const [k, v] of flattenToParams(remaining, "", queryParamFormat)) {
        newUrl.searchParams.append(k, v);
      }
      newInit.body = undefined;
    } else {
      newInit.body = JSON.stringify(remaining);
    }

    return globalThis.fetch(newUrl.toString(), newInit);
  };
}
`;
}
